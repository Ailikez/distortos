Change Log
==========

All notable changes to this project will be documented in this file. This project adheres to
[Semantic Versioning](http://semver.org/).

[Unreleased](https://github.com/DISTORTEC/distortos/compare/v0.3.0...HEAD)
--------------------------------------------------------------------------

### Added

- Set `STKALIGN` bit in `SCB->CCR` for *ARM Cortex-M3 r1p1* (like *STM32F1*). Thanks to that, stack will be
automatically aligned to 8-bytes on exception entry, which is required by *AAPCS*. This bit is set by default on all
other *ARM Cortex-M* cores.
- `FATAL_ERROR()` macro with weak `fatalErrorHook()`.
- "Check context of functions" option in *Kconfig* menus. When this option is selected, the context of functions which
must not be used from interrupt context (all blocking functions, all `Mutex` functions and all functions from
`ThisThread` namespace) is checked during run-time. If a violation is detected, `FATAL_ERROR()` is called with
appropriate message. See help of the new option for more info.
- "Check stack pointer range during context switch" option in *Kconfig* menus. Selecting this option enables simple
range checking of preempted thread's stack pointer during context switches. Such check is relatively fast, but cannot
detect all stack overflows. `FATAL_ERROR()` is called with appropriate message when an overflow is detected. Check new
option's help for more info.
- "Check stack guard contents during context switch" option in *Kconfig* menus. When enabled, this option extends stacks
for all threads (including `main()` thread) with a "stack guard" at the overflow end. This "stack guard" - just as the
whole stack - is filled with a sentinel value during thread initialization. During each context switch contents of
preempted thread's "stack guard" are checked - if any byte has changed, FATAL_ERROR() will be called with appropriate
message. This method is able to detect stack overflows much more reliably than simple stack pointer range checking and
is still sufficiently fast, assuming that the size of "stack guard" is reasonable. For more info, check new option's
help.
- "Check stack pointer range during system tick" and "Check stack guard contents during system tick" options in
*Kconfig* menus, which are similar to "Check stack pointer range during context switch" and "Check stack guard contents
during context switch" respectively, but executed during every system tick.

### Changed

- Changed placement of fixed stacks for *ARMv6-M* and *ARMv7-M* in generated linker script. Stack for interrupts ("main"
stack) is located at the beginning of RAM, so any stack overflow during interrupt handling will cause a HardFault
exception. Stack for `main()` thread ("process" stack) is placed at the end or RAM, after heap, which introduces a
potential safety margin for any stack overflows in this thread - as long as heap's last block is not allocated, the
memory below this stack is not used.
- Stacks are filled with 0xed419f25 instead of 0. Using 0 is not a reliable method to detect stack usage/overflow, as 0
is very likely to be used in the application (for example to zero-initialize variables).

### Fixed

- Added `ChipSpiMasterLowLevel` and `ChipUartLowLevel` classes to "devices" group in *API* reference generated by
*doxygen*.

[0.3.0](https://github.com/DISTORTEC/distortos/compare/v0.2.0...v0.3.0) - 2016-11-24
------------------------------------------------------------------------------------

### Added

- Support for periodic execution of software timers. All overloads of `SoftwareTimer::start()` were extended with
optional second argument with period. If the period is 0 (which is the default value), software timer's function is
executed only once. Otherwise it will be executed periodically until the software timer is stopped.
- `devices::UartBase` interface class, which can be used as a private base for devices using UART interface.
- `devices::UartLowLevel` interface class, which is a low-level interface to hardware-dependent UART driver.
- `chip::ChipUartLowLevel` class - interrupt-driven implementation of `devices::UartLowLevel` interface for *STM32F0*,
*STM32F1* and *STM32F4*.
- `devices::SpiMasterBase` interface class, which can be used as a private base for devices using SPI as bus master.
- `devices::SpiMasterLowLevel` interface class, which is a low-level interface to hardware-dependent SPI bus master
driver.
- `chip::ChipSpiMasterLowLevel` class - interrupt-driven implementation of `devices::SpiMasterLowLevel` interface for
*STM32F0*, *STM32F1* and *STM32F4*.
- "Peripherals configuration" *Kconfig* menu, where low-level drivers for SPI bus master and U[S]ART can
be selected.
- `uarts.hpp` header for *STM32F0*, *STM32F1* and *STM32F4* with declarations of all enabled low-level U[S]ART drivers.
- `spis.hpp` header for *STM32F0*, *STM32F1* and *STM32F4* with declarations of all enabled low-level SPI master
drivers.
- `devices::SerialPort` class - universal serial port device with an interface similar to standard files (`open()`,
`close()`, `read()`, `write()`). `read()` and `write()` member functions of this class support both blocking (with
or without timeout) and non-blocking behaviour. Convenient wrappers for reading/writing with timeout are also provided:
`tryReadFor()`, `tryReadUntil()`, `tryWriteFor()` and `tryWriteUntil()`.
- `estd::ScopeGuard` template class, which can be used to execute bound function on scope exit using RAII pattern.
- `devices::Rs485` class - *RS-485* device with all features of `devices::SerialPort` and with automatic management
of "driver enable" output pin.
- `devices::SpiMaster` and `devices::SpiDevice` classes, which enable easy communication with multiple SPI slave devices
connected to the same SPI bus master.
- `devices::SpiEeprom` class which is a driver for common SPI EEPROM chips: *Atmel AT25xxx*,
*ON Semiconductor CAT25xxx*, *ST M95xxx*, *Microchip 25xxxxx* or similar.
- Support for `assert()` - override of newlib's `__assert_func()`, weak `assertHook()` for application and option to
enable/disable assertions in *Kconfig* menus.
- Extend `estd::ContiguousRange` with support for `std::array`, constructor for non-const -> const conversions and
various useful functions: `cbegin()`, `cend()`, `rbegin()`, `rend()`, `crbegin()`, `crend()`.
- Option in *Kconfig* menus for manual configuration of ROM's offset and size in generated linker script. This can be
useful when the device has a bootloader at the beginning of flash, when the application is a bootloader and/or when the
application uses a few last ROM pages for its own purposes (e.g. emulated EEPROM, storing configuration, logging, ...).
- `architecture::isInInterruptContext()` which checks whether thread or interrupt context is currently active. An
example use is when the application needs to decide between blocking or non-blocking behaviour, as blocking is not
possible in interrupt context.
- `protected` `ChipInputPin::getInvertedMode()`, `ChipInputPin::setInvertedMode()`, `ChipOutputPin::getInvertedMode()`
and `ChipOutputPin::setInvertedMode()` functions, which - if needed - can be made `public` by deriving from these
classes.
- Missing tests of timers: basic operations of periodic timers, synchronous and asynchronous stops and restarts, reading
of state in timer's function.
- New chips: *STM32F071C8*, *STM32F101C4*, 8 *STM32F412* chips, 3 *STM32F469Vx* chips, 3 *STM32F469Zx* chips, 2
*STM32F479Vx* chips and 2 *STM32F479Zx* chips.
- New package types: *UFQFPN48* for *STM32F101C8*, *LQFP48* for *STM32F410CB*, *UFBGA64* for *STM32F410RB*, *LQFP176*
for *STM32F469IG*.

### Changed

- Replace generator of `distortosConfiguration.h` that uses *AWK* (`makeDistortosConfiguration.awk`) with the one using
shell, *cat* and *sed* (`makeDistortosConfiguration.sh`). With this change *AWK* is no longer needed to configure &
build this project.
- Merge GPIO drivers for *STM32*.
- Update *CMSIS-STM32F0* to version 1.6.0.
- Update *CMSIS-STM32F1* to version 1.4.0.
- Update *CMSIS-STM32F4* to version 1.13.0.

### Fixed

- Fix generated linker scripts for older versions of *ld* (like 2.24.0.20141128), where hidden symbols cannot be used in
expressions.
- Fix failure of test application for new versions of "official" ARM toolchain (5.x).
- Fixes necessary for compilation and proper behaviour in *GCC 6.2.0* - mainly related to `reinterpret_cast<>()` in
constant expressions.
- *ST's* website no longer lists *WLCSP49* as package type for *STM32F401CB*.

[0.2.0](https://github.com/DISTORTEC/distortos/compare/v0.1.0...v0.2.0) - 2016-05-03
------------------------------------------------------------------------------------

### Added

- Support for *ARMv6-M* (*ARM Cortex-M0*, *ARM Cortex-M0+* and *ARM Cortex-M1*) architecture.
- Support for all 72 [STM32F0](http://www.st.com/stm32f0) chips.
- Support for all 94 [STM32F1](http://www.st.com/stm32f1) chips.
- Support and test configurations for [NUCLEO-F091RC](http://www.st.com/web/catalog/tools/PF260944) board with *STM32F0*
chip, [NUCLEO-F103RB](http://www.st.com/nucleoF103RB-pr) board with *STM32F1* chip and
[NUCLEO-F429ZI](http://www.st.com/web/catalog/tools/PF262637) board with *STM32F4* chip.
- `make oldconfig` target, which can be used to update currently selected configuration asking about new options.
- `make olddefconfig` target, which can be used to update currently selected configuration with default values of new
options.
- `forAllConfigurations.sh` script, which can be used to run any command - passed in first argument - for all
configurations found in provided (optional) search path - passed in second argument, default - current path ("."). One
use case is updating all configurations - `./scripts/forAllConfigurations.sh "make oldconfig"` or
`./scripts/forAllConfigurations.sh "make olddefconfig"`.
- Ability to delete some folders - if you don't use their contents - without breaking *make*/*tup* build and *Kconfig*
menus. You can obviously delete anything from `configurations/`, including the entire folder. The same is true for
`documentation/` directory if you don't plan to generate *API* reference with *doxygen*. In case of `external/`,
`source/architecture/`, `source/board/` and `source/chip/` you can delete any number of complete components or group of
components - e.g. you can delete `source/board/STM32/STM32F4/STM32F4DISCOVERY/` (port for single board) and/or
`source/board/STM32/STM32F4/` (group of ports for boards), but you shouldn't delete just
`source/board/STM32/STM32F4/STM32F4DISCOVERY/include/` (part of port for single board). Additionally you can delete
entire `source/board/` and/or `test/` folders.
- Ability to add configurations of custom applications to *Kconfig* menus. User can add any number of files named
`Kconfig-applicationOptions` anywhere in the project, and they will all be automatically included in the
"Applications configuration" menu. The same is possible for custom boards, chips and architectures, but these are
slightly more complicated, as multiple files are needed.
- Configuration of *SRAM1*, *SRAM2* and *SRAM3* regions' unification for *STM32F4* chips.
- Support for additional memory regions of *STM32F4* chips (*BKPSRAM*, *CCM*, *SRAM2*, *SRAM3*) in generated linker
scripts.
- Ability to use *ARMv7-M*'s *PRIMASK* to disable all interrupts during critical sections when "Interrupt priority
disabled in critical sections" (*ARCHITECTURE_ARMV7_M_KERNEL_BASEPRI*) options is set to 0. This is the new default
setting, as this is a more conservative (and thus safer for a beginner) approach, which doesn't require any special
configuration of interrupt priorities (default value is 0).
- Support for optional inversion to all implementations of `ChipInputPin` and `ChipOutputPin`.
- `buttons.hpp` header with board buttons for all supported boards.
- `clocks.hpp` header with definition of clocks for selected chip.
- New package type for *STM32F411C* chips - the website lists *WLCSP49* variant now.

### Changed

- Change names of elements of all `enum class` from `ALL_CAPS` or `PascalCase` to `camelCase` for consistency with
their use as constants and with other enums.
- Replace individual linker script generators for *STM32F1* and *STM32F4* families with generic script for
*ARMv7-M*-based chips. The new generator also supports arbitrary number of additional memories (like *BKPSRAM*, *CCM*,
...), which can be defined with command line arguments.
- Reorganize and simplify *Kconfig* menus for *STM32F1* and *STM32F4*.
- Improve configuration and initialization of chip clocks for *STM32F1* and *STM32F4*.
- Move configuration of *SysTick* timer from `chip::lowLevelInitialization()` to `architecture::startScheduling()` for
all *ARMv6-M* and *ARMv7-M* targets.
- Change allowed range of *PLLN* for *STM32F446* chips from \[192; 432\] (first revision of the reference manual) to
\[50; 432\] (second revision of the reference manual).
- API reference generated by *doxygen* no longer includes code from disabled folders. This way documentation for
particular configuration has entries only for single selected chip & architecture, single selected board (if any) and
only for enabled applications - sources that are excluded from compilation are not parsed by *doxygen*.

### Fixed

- Fix insufficient dependencies for "PLLR" option in system clock source configuration for *STM32F4*. Main PLL's "/R"
output cannot be used as system clock if PLL is disabled.
- Fix invalid definition of templated variants of `Semaphore::tryWaitFor()` and `Semaphore::tryWaitUntil()`.
- Added missing *STM32F429NG* chip to *Kconfig* configuration menus.
- Fix *make* build for constructs like `CXXFLAGS_$(d)someFileName.cpp := ...` not working correctly in top-level folder
of the project (where `$(d)` is `./`).

0.1.0 - 2016-02-26
------------------

### Added

- Build infrastructure for *make* and *tup*.
- Fully preemptive scheduling with 256 priority levels. FIFO and round-robin scheduling policies. Completely static
implementation.
- Static and dynamic threads. Thread can execute any function type (regular function, member function, stateless
functor, lambda) with any number of arguments of any type. Both thread types can be joined, while dynamic threads can
also be detached.
- Semaphores which can also be configured to work as binary semaphores during construction. Completely static
implementation. `constexpr` constructor. Non-blocking functions can be used in interrupt handlers.
- Mutexes which support various types (normal, error-checking, recursive) and protocols (normal, priority inheritance,
priority protection). Priority inheritance protocol works with no limitations: through any number of inheritance
"levels" and with any number of mutexes locked by threads in any order. Completely static implementation. `constexpr`
constructor.
- Condition variables which can work with mutexes. Completely static implementation. `constexpr` constructor.
- `callOnce()` and `OnceFlag` - equivalents of `std::call_once()` and `std::once_flag` from C++11 or
`pthread_once()` and `pthread_once_t` from POSIX. Completely static implementation. `OnceFlag` has `constexpr`
constructor.
- Message and FIFO queues, both in two flavors: with proper support for C++ objects and for binary serializable types
(like POD types). 256 priority levels in message queues. Available in static and dynamic versions. Non-blocking
functions can be used in interrupt handlers.
- Support for POSIX-style signals with synchronous (waits) and asynchronous (signal handlers) API. Signals can be
"generated" and "queued" with value. Completely static implementation. Non-blocking functions can be used in interrupt
handlers.
- One-shot static software timers which can execute any function type (regular function, member function, stateless
functor, lambda) with any number of arguments of any type.
- Basic device drivers for input and output pin.
- Support for *ARMv7-M* (*ARM Cortex-M3* and *ARM Cortex-M4(F)*) architecture. FPU can be used in any number of threads
and interrupt handlers at the same time.
- Support for [STM32F4](http://www.st.com/stm32f4) chips.
- Support and test configurations for 3 boards with *STM32F4* chips:
[32F429IDISCOVERY](http://www.st.com/web/catalog/tools/PF259090), [NUCLEO-F401RE](http://www.st.com/nucleoF401RE-pr) and
[STM32F4DISCOVERY](http://www.st.com/web/catalog/tools/PF252419).
- Extensive functional tests for all implemented functionalities.
- Configuration with mconf tool from [kconfig-frontends](http://ymorin.is-a-geek.org/projects/kconfig-frontends).
- `README.md` file with introduction and information about configuration & building.
- Integration with [Travis CI](https://travis-ci.org/DISTORTEC/distortos) service.
